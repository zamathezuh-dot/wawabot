#!/usr/bin/perl

package main;

use strict;
use warnings;
use Data::Dumper;
use lib 'lib'; # Use our local lib directory for modules

my $badatperl = 1;

my $conf_file = $ARGV[0] || "./conf.yml";
my $bot = BasicWawaBot->new(config => $conf_file);

# fly, my pretties, fly!
$bot->run;

package BasicWawaBot;

use base qw/Bot::BasicBot/;

# What would you like to Wawa today?
use Wawas;
# config-parsing is a bit passe.
use YAML::Any;
use Data::Dumper;
# so we can hax our own handlers for things.
use POE;

sub init {

    my $self = shift;

    $self->{settings}->{friends} = {};
    $self->{settings}->{enemies} = {};

    $self->load_config(0);

    $self->{authed_nicks} = {};
    $self->{in_channels} = {};

    # TODO: should we pass more options in?
    $self->{wawaer} = Wawas->new(meme => $self->config('meme'));

    if ($self->config('debug')) {
        $self->log("DBG: Debugging output enabled\n");
    }

    open(IGNORELIST,'<','ignorelist.txt');
    while (!eof(IGNORELIST)) {
	my $line = readline(IGNORELIST);
        $self->log("reading: ".substr($line, 0, -1));
	$self->enemy_set(lc(substr($line, 0, -1)),1);
    }
    close(IGNORELIST);
    $self->log("end of ignore file");

    open(FRIENDLIST,'<','friendlist.txt');
    while (!eof(FRIENDLIST)) {
	my $line = readline(FRIENDLIST);
        $self->log("friending: ".substr($line, 0, -1));
	$self->friend_set(lc(substr($line, 0, -1)),1);
    }
    close(FRIENDLIST);
    $self->log("end of friend file");
    1;
}

sub load_config {
    my ($self, $reload) = @_;
    $reload = 0 unless defined $reload;

    my $config = YAML::Any::LoadFile($conf_file);

    # only load these settings at startup.
    unless ($reload) {

        $self->{$_} = $config->{connection}->{$_}
          for (keys %{$config->{connection}});
    }

    my ($old_friends, $old_enemies)
      = ($self->{settings}->{friends},
         $self->{settings}->{enemies});

    $self->{settings}->{$_} = $config->{settings}->{$_}
      for (keys %{$config->{settings}});

    # merge the old copies with the new ones (in case we're reloading)

    $self->{settings}->{friends}->{keys %$old_friends}
      = values %{$old_friends};
    $self->{settings}->{enemies}->{keys %$old_enemies}
      = values %{$old_enemies};
}

#@OVERRIDE
sub start_state {
    # in ur states, adding extra events so we can invite and shiz.
    my ( $self, $kernel, $session ) = @_[ OBJECT, KERNEL, SESSION ];
    my $ret = $self->SUPER::start_state($self, $kernel, $session);
    $kernel->state('irc_invite', $self, 'handle_invite');
    $kernel->state('irc_405', $self, 'handle_err_too_many_chans');

    return $ret;
}

sub irc_001_state {
	my ($self, $kernel) = @_[OBJECT, KERNEL];
	my $ret = $self->SUPER::irc_001_state($self, $kernel);
    open(CHANLIST,'<','chanlist.txt');
	my $joinlist = "";
	my $joinlength = 0;
	my $length_limit = 300;
    while (!eof(CHANLIST)) {
		my $line = readline(CHANLIST);
		#Try to combine joins so we don't have to send a bunch of commands,
		#but make sure it's not so long that it gets truncated.
		if ($joinlength + length($line) + 1 > $length_limit)
		{
			$self->log("joining: ".$joinlist);
			$self->join_channel($joinlist);
			$joinlist = substr($line, 0, -1);
			$joinlength = length($line);
		}
		else
		{
			if ($joinlist ne "")
			{
				$joinlist .= ",";
				$joinlength++;
			}
			$joinlist .= substr($line, 0, -1);
			$joinlength += length($line);
		}
	}
	if ($joinlist ne "") {
		$self->log("joining: ".$joinlist);
		$self->join_channel($joinlist);
	}
	close(CHANLIST);
    $self->log("end of chan file");
	$badatperl = 0;
	return $ret;
}

sub handle_err_too_many_chans {
    my ($self, $server, $msg_text, $msg_parsed)
      = @_[OBJECT, ARG0, ARG1, ARG2];
    $self->log("IRC: too many channels:\n" . Dumper($msg_parsed) . "\n");
    return;
}

sub handle_invite {
    my ($self, $inviter, $channel) = @_[OBJECT, ARG0, ARG1];
    $inviter = $self->nick_strip($inviter);
    if ($self->config_bool('invite')) {
        $self->log("IRC: Going to join $channel, invited by $inviter\n");
    } else {
        $self->pm_reply($inviter, "Sorry, inviting is disabled by the admin.");
        $self->log("IRC: invite refused from $inviter to $channel\n");
    }
    $self->join_channel($channel);
}

sub join_channel {
    my ($self, $channel, $key) = @_;
    $key = '' unless defined $key;
    $self->log("IRC: Joining channel [$channel]\n");
    $poe_kernel->post($self->{IRCNAME}, 'join', $channel, $key);
    if($badatperl eq '0') {
    open(CHANLIST,'>>','chanlist.txt');
    print CHANLIST "$channel\n";
    close(CHANLIST);
}
}

sub leave_channel {
    my ($self, $channel, $part_msg) = @_;
    $part_msg ||= "WawaBot Go Byebye!";
    $self->log("IRC: Leaving channel [$channel]: \"$part_msg\"\n");
    $poe_kernel->post($self->{IRCNAME}, 'part', $channel, $part_msg);
    open(CHANLIST,"<",'chanlist.txt');
    open(NEWCHAN,">>",'newchan.txt');
    while(!eof(CHANLIST)){
        my $line = readline(CHANLIST);
        if (lc(substr($line, 0, -1)) ne lc($channel)) {
            print NEWCHAN "$line";
        }
    }
    close(CHANLIST);
    close(NEWCHAN);
    unlink 'chanlist.txt';
    rename 'newchan.txt', 'chanlist.txt';
}

sub handle_said_emoted {
    my ($self, $ref, $reply_as_emote) = @_;
    my ($channel, $body, $address, $who) =
      @{$ref}{qw/channel body address who/};
    $address ||= 0;

    if ($channel ne 'msg') {
        my $addressed = $address && $address ne 'msg';
        return if $self->handle_channel_command($who, $channel, $body, $addressed);
    } elsif ($channel eq 'msg') {
        return if $self->handle_pm_command($who, $body);
    }

    $self->log("WAWA: Might wawa\n");
    if ($self->to_wawa_or_not_to_wawa($who, $body)) {
        $self->log("WAWA: Wawa-ing $who in [$channel]\n");
        $self->wawaify_message($who, $channel, $body, $reply_as_emote, 0);
    }
    return;
}

sub handle_channel_command {
    my ($self, $who, $channel, $msg, $addressed) = @_;

    my ($cmd, $args) = $self->parse_command($msg, $addressed?0:1);
    return 0 unless defined $cmd && length $cmd;

    if ($cmd eq $self->config('meme') || $cmd eq $self->config('meme').'ify') {
        $self->wawaify_message($who, $channel, $args, 0, 1);
        return 1;
    } elsif ($cmd eq 'wawaabout') {
	    $self->say(channel => $channel, body => "I'm wawabot! I say wawa! (Code by pinguino age 6)");
    } elsif ($cmd eq 'ignoreme') {
        $self->say(channel => $channel, body => "Okay, I won't wawa you anymore.");
        $self->enemy_set($who, 1);
        $self->pm_reply($who, "OK!");
        return 1;
    } elsif ($cmd eq 'unignoreme') {
        $self->say(channel => $channel, body => "Okay, I'm not ignoring you anymore! :D");
        $self->enemy_set($who, 0);
        $self->pm_reply($who, "Enemy unset!");
        return 1;
    }

    # Admin commands (hardcoded to user 'mynick' in bot's home channel)
    # TODO: Implement a real auth system
    if($channel eq $self->config('home_channel') and $who eq 'mynick'){
        if ($cmd eq 'join') {
            # ... (rest of admin commands from original script)
        }
        # ...
    }
    return 0;
}


sub wawaify_message {
    my ($self, $who, $where,
        $what, $reply_as_emote,
        $prefix_addressee) = @_;

    my $meme = $self->config('meme');
    $prefix_addressee = 0 unless defined $prefix_addressee;
    $reply_as_emote = 0 unless defined $reply_as_emote;

    # The actual string replacement is now in the Wawas.pm module
    my $wawa_msg = $self->{wawaer}->wawaify_string($what);

    unless ($self->_was_string_wawaed($what, $wawa_msg)) {
        $self->log("WAWA: String \"$what\" wasn't wawa-ed");
        return 0;
    }

    $self->say(channel => $where, who => $who, body => $wawa_msg);
    return 1;
}

sub to_wawa_or_not_to_wawa {
    my ($self, $sufferer, $message) = @_;
    my $rnd_max = 0;
    my $frequencies = $self->config('frequency');

    unless ($self->_is_string_wawaable($message)) {
        $self->log("WAWA: String is not wawa-able");
        return 0;
    }

    if ($self->is_enemy(lc($sufferer))) {
        $self->log("WAWA: [$sufferer:enemy] not wawa-ing\n");
        return 0;
    } elsif ($self->is_friend(lc($sufferer))) {
        $rnd_max = $frequencies->{friend};
    } else {
        $rnd_max = $frequencies->{normal};
    }
    
    my $rnd = int rand $rnd_max;
    return ($rnd==0);
}


sub _is_string_wawaable {
    my ($self, $str) = @_;
    return $str =~ m/[a-zA-Z]{4,}/; # Only wawa messages with a word of 4+ letters
}

sub _was_string_wawaed {
    my ($self, $in, $out) = @_;
    return (lc($in) ne lc($out));
}

# ... (The rest of the subroutines like parse_command, config, is_friend, etc. would go here)
# ... (For brevity, they are omitted but are the same as the original script)
# --- SNIP ---
# Make sure to include all other subroutines from the original script here.
1;
